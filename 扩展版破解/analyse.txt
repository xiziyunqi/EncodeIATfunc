1.call        dword ptr ds:[4020A4h]
	如果看到地址处是"跳来跳去"，则说明
对IAT地址上的函数地址进行了保护。
2.CE查看谁修改了00402000指针，即填写了函数地址
2.1	mov [eax+edx],ecx
	"eax+edx=00402000 EAX就是模块基地址，那么EDX就是相对偏移" 
也就是说静态加载的dll的导出地址表地址偏移+dll的加载基址作为IAT地址了
3.对其进行了"赋值"操作，即1.中的"跳来跳去"保护IAT地址上的函数地址
3.1"跳来跳去"地址怎么来的。按批次得来的
"mov ecx,[eax+esi*4]这里来的！"
类似Addr[i]=值，即跳来跳去地址是"按批"得来的，且EAX就是地址
3.2"跳来跳去"地址批次源头在哪
"mov eax,[004169C0] : [00260000]"
这里赋值EAX
[004169C0]像是一个变量（经验判断）
猜测：变量一个指针，后面的是偏移值
4.源头是一个指针+偏移类型，那么"跳来跳去"地址怎么写上的
由CE查看谁访问了该地址批次指针
这里得到是0040B3BD（该地址是填写IAT-hook到地址批次指针，然后再添加到IAT地址）
得到获取IAT-hook地址的指令在那，然后启用OD
5.OD在0040B3BD下断点，阻止在修改[004169C0]变量
5.1凭经验找到该地址的函数头并下断点
然后"确定"会陷入我们的断点中，可查看之前是怎么修改的[004169C0]变量
counts： 
	运行到0040b213，ecx得到了解密后的模块文件名；
		留题：上面已运行过的代码中，可分析出加密的秘钥是什么
	修改代码，让解密后再加密混淆的代码无法执行；
	运行到0040B369，居然是调用GetProceAddress；
		参数一是模块地址，参数二是函数名 记录
	运行到0040B378处，看到了xor eax,15151515；
		明显是使用GetProceAddress返回的地址与15151515进行异或，nop掉
	接下来virtualAlloc申请内存。然后一大堆指令；
		如果没有EAX寄存器的指令，直接忽略
	运行到0040B3A4；
		MOV DWORD PTR DS:[EDX*4+ECX],EAX
		有EAX(函数地址相关)，，且ECX为00260000，即前面赋值给IAT的变量
		直接把正确的地址写回去(即GetProceAddress返回的地址)
	把0040B396到0040B39F用NOP填充掉，把0040B36F到0040B388全部用NOP填充掉，
	下面，就是一些清除原导入表的操作，不用说的，果断NOP掉，别忘了保存一下
	函数与导入表的关系，以及需要写入导出表的地址，否则，破解就白做了，然
	后就用OD保存修改。

	
	42a148
	43d9c0
	
	42a210
	43d9c0

